Index: community/platform/util/src/com/intellij/util/xmlb/PrimitiveValueBinding.java
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/PrimitiveValueBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/PrimitiveValueBinding.java	(date 1425025933000)
@@ -1,63 +0,0 @@
-/*
- * Copyright 2000-2014 JetBrains s.r.o.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.intellij.util.xmlb;
-
-import org.jdom.Attribute;
-import org.jdom.Content;
-import org.jdom.Text;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-class PrimitiveValueBinding extends Binding {
-  private final Class<?> myType;
-
-  public PrimitiveValueBinding(@NotNull Class<?> myType, @Nullable Accessor accessor) {
-    super(accessor);
-
-    this.myType = myType;
-  }
-
-  @Override
-  public Object serialize(Object o, Object context, SerializationFilter filter) {
-    return new Text(String.valueOf(o));
-  }
-
-  @Override
-  @Nullable
-  public Object deserialize(Object o, @NotNull Object node) {
-    return convertString(node instanceof Attribute ? ((Attribute)node).getValue() : ((Content)node).getValue());
-  }
-
-  @Override
-  public Object deserializeEmpty(Object context) {
-    return convertString("");
-  }
-
-  @Nullable
-  protected Object convertString(String value) {
-    return XmlSerializerImpl.convert(value, myType);
-  }
-
-  @Override
-  public boolean isBoundTo(Object node) {
-    throw new UnsupportedOperationException("Method isBoundTo is not supported in " + getClass());
-  }
-
-  @Override
-  public Class getBoundNodeType() {
-    return Text.class;
-  }
-}
Index: community/platform/util/src/com/intellij/util/xmlb/XmlSerializerUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/XmlSerializerUtil.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/XmlSerializerUtil.java	(revision )
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.intellij.util.xmlb;
 
 import org.jetbrains.annotations.NotNull;
@@ -28,19 +27,19 @@
     assert from.getClass().isAssignableFrom(to.getClass()) : "Beans of different classes specified: Cannot assign " +
                                                              from.getClass() + " to " + to.getClass();
     for (Accessor accessor : BeanBinding.getAccessors(to.getClass())) {
-      accessor.write(to, accessor.read(from));
+      accessor.set(to, accessor.read(from));
     }
   }
 
   public static <T> T createCopy(@NotNull T from) {
     try {
-      final T to = (T)from.getClass().newInstance();
+      T to = (T)from.getClass().newInstance();
       copyBean(from, to);
       return to;
     }
     catch (Exception ignored) {
-    }
-    return null;
+      return null;
+    }
   }
 
   public static List<Accessor> getAccessors(Class aClass) {
Index: community/platform/util/src/com/intellij/util/xmlb/TextBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/TextBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/TextBinding.java	(revision )
@@ -15,44 +15,90 @@
  */
 package com.intellij.util.xmlb;
 
-import org.jdom.Content;
 import org.jdom.Text;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-public class TextBinding extends Binding {
-  private volatile Binding myBinding;
+import java.util.Date;
 
+class TextBinding extends Binding {
+  private final Class<?> valueClass;
+
   public TextBinding(@NotNull Accessor accessor) {
     super(accessor);
+
+    valueClass = XmlSerializerImpl.typeToClass(accessor.getGenericType());
   }
 
   @Nullable
   @Override
-  public Object serialize(Object o, @Nullable Object context, SerializationFilter filter) {
-    Object v = myAccessor.read(o);
-    if (v == null) {
-      return null;
+  public Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter) {
+    Object value = myAccessor.read(o);
+    return value == null ? null : new Text(convertToString(value));
-    }
+  }
-    Object node = myBinding.serialize(v, context, filter);
-    if (node == null) {
-      return null;
+
+  @NotNull
+  static String convertToString(@NotNull Object value) {
+    if (value instanceof Date) {
+      return Long.toString(((Date)value).getTime());
     }
-    else if (node instanceof Text) {
-      return node;
-    }
     else {
-      return new Text(((Content)node).getValue());
+      return value.toString();
     }
   }
 
   @Override
   @Nullable
   public Object deserialize(Object context, @NotNull Object node) {
-    myAccessor.write(context, myBinding.deserialize(context, node));
+    String value = ((Text)node).getValue();
+    doSet(context, value, myAccessor, valueClass);
     return context;
   }
 
+  static void doSet(@NotNull Object host, @Nullable String value, @NotNull Accessor accessor, @NotNull Class<?> valueClass) {
+    if (value == null) {
+      accessor.set(host, null);
+    }
+    else if (valueClass == String.class) {
+      accessor.set(host, value);
+    }
+    else if (valueClass == int.class || valueClass == Integer.class) {
+      accessor.setInt(host, Integer.parseInt(value));
+    }
+    else if (valueClass == boolean.class || valueClass == Boolean.class) {
+      accessor.setBoolean(host, Boolean.parseBoolean(value));
+    }
+    else if (valueClass == double.class || valueClass == Double.class) {
+      accessor.setDouble(host, Double.parseDouble(value));
+    }
+    else if (valueClass == float.class || valueClass == Float.class) {
+      accessor.setFloat(host, Float.parseFloat(value));
+    }
+    else if (valueClass == long.class || valueClass == Long.class) {
+      accessor.setLong(host, Long.parseLong(value));
+    }
+    else if (valueClass.isEnum()) {
+      Object deserializedValue = null;
+      for (Object enumConstant : valueClass.getEnumConstants()) {
+        if (enumConstant.toString().equals(value)) {
+          deserializedValue = enumConstant;
+        }
+      }
+      accessor.set(host, deserializedValue);
+    }
+    else if (Date.class.isAssignableFrom(valueClass)) {
+      try {
+        accessor.set(host, new Date(Long.parseLong(value)));
+      }
+      catch (NumberFormatException e) {
+        accessor.set(host, new Date(0));
+      }
+    }
+    else {
+      accessor.set(host, value);
+    }
+  }
+
   @Override
   public boolean isBoundTo(Object node) {
     return node instanceof Text;
@@ -61,13 +107,5 @@
   @Override
   public Class getBoundNodeType() {
     return Text.class;
-  }
-
-  @Override
-  public void init() {
-    myBinding = XmlSerializerImpl.getBinding(myAccessor);
-    if (!Text.class.isAssignableFrom(myBinding.getBoundNodeType())) {
-      throw new XmlSerializationException("Can't use attribute binding for non-text content: " + myAccessor);
-    }
   }
 }
Index: community/plugins/devkit/src/actions/ShowSerializedXmlAction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/plugins/devkit/src/actions/ShowSerializedXmlAction.java	(date 1425025933000)
+++ community/plugins/devkit/src/actions/ShowSerializedXmlAction.java	(revision )
@@ -79,7 +79,7 @@
     final String className = ClassUtil.getJVMClassName(psiClass);
 
     final Project project = getEventProject(e);
-    CompilerManager.getInstance(project).make(new FileSetCompileScope(Arrays.asList(virtualFile), new Module[]{module}), new CompileStatusNotification() {
+    CompilerManager.getInstance(project).make(new FileSetCompileScope(Collections.singletonList(virtualFile), new Module[]{module}), new CompileStatusNotification() {
       @Override
       public void finished(boolean aborted, int errors, int warnings, CompileContext compileContext) {
         if (aborted || errors > 0) return;
@@ -194,10 +194,9 @@
     public Object createObject(Class<?> aClass, FList<Type> processedTypes) throws Exception {
       final Object o = aClass.getDeclaredConstructor().newInstance();
       for (Accessor accessor : XmlSerializerUtil.getAccessors(aClass)) {
-        final Type type = accessor.getGenericType();
-        Object value = createValue(type, processedTypes);
+        Object value = createValue(accessor.getGenericType(), processedTypes);
         if (value != null) {
-          accessor.write(o, value);
+          accessor.set(o, value);
         }
       }
       return o;
Index: community/platform/util/src/com/intellij/util/xmlb/XmlSerializerImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/XmlSerializerImpl.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/XmlSerializerImpl.java	(revision )
@@ -83,34 +83,49 @@
   @Nullable
   static Element serializeIfNotDefault(@NotNull Object object, @NotNull SerializationFilter filter) {
     Class<?> aClass = object.getClass();
-    return (Element)_getClassBinding(aClass, aClass, null).serialize(object, null, filter);
+    Binding binding = _getClassBinding(aClass, aClass, null);
+    assert binding != null;
+    return (Element)binding.serialize(object, null, filter);
   }
 
   static Binding getBinding(@NotNull Type type) {
-    return getTypeBinding(type, null);
+    return _getClassBinding(typeToClass(type), type, null);
   }
 
+  @Nullable
   static Binding getBinding(@NotNull Accessor accessor) {
-    return getTypeBinding(accessor.getGenericType(), accessor);
+    Type type = accessor.getGenericType();
+    return _getClassBinding(typeToClass(type), type, accessor);
   }
 
-  static Binding getTypeBinding(@NotNull Type type, @Nullable Accessor accessor) {
-    Class<?> aClass;
+  @NotNull
+  static Class<?> typeToClass(@NotNull Type type) {
     if (type instanceof Class) {
-      aClass = (Class<?>)type;
+      return (Class<?>)type;
     }
     else if (type instanceof TypeVariable) {
       Type bound = ((TypeVariable)type).getBounds()[0];
-      aClass = bound instanceof Class ? (Class)bound : (Class<?>)((ParameterizedType)bound).getRawType();
+      return bound instanceof Class ? (Class)bound : (Class<?>)((ParameterizedType)bound).getRawType();
     }
     else {
-      aClass = (Class<?>)((ParameterizedType)type).getRawType();
+      return (Class<?>)((ParameterizedType)type).getRawType();
     }
-    return _getClassBinding(aClass, type, accessor);
   }
 
-  @NotNull
+  @Nullable
   private static synchronized Binding _getClassBinding(@NotNull Class<?> aClass, @NotNull Type originalType, @Nullable Accessor accessor) {
+    if (aClass.isPrimitive() ||
+        aClass == String.class ||
+        aClass == Integer.class ||
+        aClass == Long.class ||
+        aClass == Boolean.class ||
+        aClass == Double.class ||
+        aClass == Float.class ||
+        aClass.isEnum() ||
+        Date.class.isAssignableFrom(aClass)) {
+      return null;
+    }
+
     Pair<Type, Accessor> key = Pair.create(originalType, accessor);
     Map<Pair<Type, Accessor>, Binding> map = getBindingCacheMap();
     Binding binding = map.get(key);
@@ -140,22 +155,15 @@
 
   @NotNull
   private static Binding _getNonCachedClassBinding(@NotNull Class<?> aClass, @Nullable Accessor accessor, @NotNull Type originalType) {
-    if (aClass.isPrimitive()) {
-      return new PrimitiveValueBinding(aClass, accessor);
-    }
     if (aClass.isArray()) {
-      return Element.class.isAssignableFrom(aClass.getComponentType())
-             ? new JDOMElementBinding(accessor) : new ArrayBinding(aClass, accessor);
+      if (Element.class.isAssignableFrom(aClass.getComponentType())) {
+        assert accessor != null;
+        return new JDOMElementBinding(accessor);
-    }
+      }
-    if (Number.class.isAssignableFrom(aClass)) {
-      return new PrimitiveValueBinding(aClass, accessor);
+      else {
+        return new ArrayBinding(aClass, accessor);
-    }
+      }
-    if (Boolean.class.isAssignableFrom(aClass)) {
-      return new PrimitiveValueBinding(aClass, accessor);
     }
-    if (String.class.isAssignableFrom(aClass)) {
-      return new PrimitiveValueBinding(aClass, accessor);
-    }
     if (Collection.class.isAssignableFrom(aClass) && originalType instanceof ParameterizedType) {
       if (accessor != null) {
         CollectionBean listBean = accessor.getAnnotation(CollectionBean.class);
@@ -177,54 +185,7 @@
         return new CompactCollectionBinding(accessor);
       }
     }
-    if (Date.class.isAssignableFrom(aClass)) {
-      return new DateBinding(accessor);
-    }
-    if (aClass.isEnum()) {
-      return new PrimitiveValueBinding(aClass, accessor);
-    }
     return new BeanBinding(aClass, accessor);
-  }
-
-  @Nullable
-  @SuppressWarnings({"unchecked"})
-  static <T> T convert(Object value, Class<T> type) {
-    if (value == null) {
-      return null;
-    }
-    if (type.isInstance(value)) {
-      return (T)value;
-    }
-    if (String.class.isAssignableFrom(type)) {
-      return (T)String.valueOf(value);
-    }
-    if (int.class.isAssignableFrom(type) || Integer.class.isAssignableFrom(type)) {
-      return (T)Integer.valueOf(String.valueOf(value));
-    }
-    if (double.class.isAssignableFrom(type) || Double.class.isAssignableFrom(type)) {
-      return (T)Double.valueOf(String.valueOf(value));
-    }
-    if (float.class.isAssignableFrom(type) || Float.class.isAssignableFrom(type)) {
-      return (T)Float.valueOf(String.valueOf(value));
-    }
-    if (long.class.isAssignableFrom(type) || Long.class.isAssignableFrom(type)) {
-      return (T)Long.valueOf(String.valueOf(value));
-    }
-    if (boolean.class.isAssignableFrom(type) || Boolean.class.isAssignableFrom(type)) {
-      return (T)Boolean.valueOf(String.valueOf(value));
-    }
-    if (char.class.isAssignableFrom(type) || Character.class.isAssignableFrom(type)) {
-      return (T)value;
-    }
-    if (type.isEnum()) {
-      final T[] enumConstants = type.getEnumConstants();
-      for (T enumConstant : enumConstants) {
-        if (enumConstant.toString().equals(value.toString())) return enumConstant;
-      }
-      return null;
-    }
-
-    throw new XmlSerializationException("Can't covert " + value.getClass() + " into " + type);
   }
 
   public static boolean isIgnoredNode(final Object child) {
Index: community/platform/util/src/com/intellij/util/xmlb/CompactCollectionBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/CompactCollectionBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/CompactCollectionBinding.java	(revision )
@@ -36,7 +36,7 @@
 
   @Nullable
   @Override
-  public Object serialize(Object o, @Nullable Object context, SerializationFilter filter) {
+  public Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter) {
     Element result = new Element(name);
     @SuppressWarnings("unchecked")
     List<String> list = (List<String>)o;
Index: community/platform/util/src/com/intellij/util/xmlb/MapBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/MapBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/MapBinding.java	(revision )
@@ -68,12 +68,12 @@
 
   @Nullable
   @Override
-  public Object serialize(Object o, @Nullable Object context, SerializationFilter filter) {
+  public Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter) {
     Map map = (Map)o;
     Element m = myMapAnnotation == null || myMapAnnotation.surroundWithTag() ? new Element(MAP) : (Element)context;
     assert m != null;
 
-    final Object[] keys = ArrayUtil.toObjectArray(map.keySet());
+    Object[] keys = ArrayUtil.toObjectArray(map.keySet());
     if (!(map instanceof TreeMap) && (myMapAnnotation == null || myMapAnnotation.sortBeforeSave())) {
       Arrays.sort(keys, KEY_COMPARATOR);
     }
@@ -84,9 +84,9 @@
       Element entry = new Element(getEntryAttributeName());
       m.addContent(entry);
 
-      Object kNode = myKeyBinding.serialize(k, entry, filter);
-      if (kNode instanceof Text) {
-        entry.setAttribute(getKeyAttributeName(), ((Text)kNode).getText());
+      Object kNode = myKeyBinding == null ? TextBinding.convertToString(k) : myKeyBinding.serialize(k, entry, filter);
+      if (kNode instanceof String) {
+        entry.setAttribute(getKeyAttributeName(), (String)kNode);
       }
       else if (kNode != null) {
         if (myMapAnnotation != null && !myMapAnnotation.surroundKeyWithTag()) {
@@ -99,18 +99,18 @@
         }
       }
 
-      Object vNode = myValueBinding.serialize(v, entry, filter);
-      if (vNode instanceof Text) {
-        entry.setAttribute(getValueAttributeName(), ((Text)vNode).getText());
+      Object serializedValue = v == null ? null : myValueBinding.serialize(v, entry, filter);
+      if (serializedValue instanceof Text) {
+        entry.setAttribute(getValueAttributeName(), ((Text)serializedValue).getText());
       }
-      else if (vNode != null) {
+      else if (serializedValue != null) {
         if (myMapAnnotation != null && !myMapAnnotation.surroundValueWithTag()) {
-          entry.addContent((Element)vNode);
+          entry.addContent((Element)serializedValue);
         }
         else {
           Element value = new Element(getValueAttributeName());
           entry.addContent(value);
-          value.addContent((Content)vNode);
+          value.addContent((Content)serializedValue);
         }
       }
     }
Index: community/platform/util/src/com/intellij/util/xmlb/TagBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/TagBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/TagBinding.java	(revision )
@@ -25,7 +25,6 @@
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 
 class TagBinding extends BasePrimitiveBinding implements MultiNodeBinding {
@@ -39,20 +38,24 @@
 
   @Nullable
   @Override
-  public Object serialize(Object o, @Nullable Object context, SerializationFilter filter) {
+  public Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter) {
     Object value = myAccessor.read(o);
-    Element v = new Element(myName);
+    Element serialized = new Element(myName);
     if (value == null) {
-      return v;
+      return serialized;
     }
 
-    assert myBinding != null;
-    Object node = myBinding.serialize(value, v, filter);
-    if (node != null && node != v) {
-      JDOMUtil.addContent(v, node);
+    if (myBinding == null) {
+      serialized.addContent(new Text(TextBinding.convertToString(value)));
     }
-    return v;
+    else {
+      Object node = myBinding.serialize(value, serialized, filter);
+      if (node != null && node != serialized) {
+        JDOMUtil.addContent(serialized, node);
-  }
+      }
+    }
+    return serialized;
+  }
 
   @Nullable
   @Override
@@ -89,17 +92,18 @@
   }
 
   private Object deserialize(Object o, List<? extends Content> children, boolean isBeanBinding) {
-    assert myBinding != null;
     if (isBeanBinding && myAccessor.isFinal()) {
+      assert myBinding != null;
       ((BeanBinding)myBinding).deserializeInto(o, (Element)children.get(0), null);
     }
-    else {
-      if (children.isEmpty() && myTextIfEmpty != null) {
-        children = Collections.<Content>singletonList(new Text(myTextIfEmpty));
+    else if (myTextIfEmpty != null && children.isEmpty()) {
+      TextBinding.doSet(o, myTextIfEmpty, myAccessor, XmlSerializerImpl.typeToClass(myAccessor.getGenericType()));
-      }
+    }
-
-      Object v = Binding.deserializeList(myBinding, myAccessor.read(o), children);
-      myAccessor.write(o, XmlSerializerImpl.convert(v, myAccessor.getValueClass()));
+    else if (myBinding == null) {
+      TextBinding.doSet(o, children.isEmpty() ? "" : children.get(0).getValue(), myAccessor, XmlSerializerImpl.typeToClass(myAccessor.getGenericType()));
+    }
+    else {
+      myAccessor.set(o, Binding.deserializeList(myBinding, myAccessor.read(o), children));
     }
     return o;
   }
Index: community/platform/util/src/com/intellij/util/xmlb/BasePrimitiveBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/BasePrimitiveBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/BasePrimitiveBinding.java	(revision )
@@ -23,8 +23,11 @@
 abstract class BasePrimitiveBinding extends Binding {
   protected final String myName;
 
-  protected final @Nullable Converter<Object> myConverter;
-  @Nullable protected Binding myBinding;
+  @Nullable
+  protected final Converter<Object> myConverter;
+
+  @Nullable
+  protected Binding myBinding;
 
   protected BasePrimitiveBinding(@NotNull Accessor accessor, @Nullable String suggestedName, @Nullable Class<? extends Converter> converterClass) {
     super(accessor);
\ No newline at end of file
Index: community/platform/util/src/com/intellij/util/xmlb/FieldAccessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/FieldAccessor.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/FieldAccessor.java	(revision )
@@ -17,6 +17,7 @@
 
 import org.jetbrains.annotations.NonNls;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
@@ -32,7 +33,7 @@
   }
 
   @Override
-  public Object read(Object o) {
+  public Object read(@NotNull Object o) {
     assert myField.getDeclaringClass().isInstance(o) : "Wrong class: " + o.getClass() + "; should be: " + myField.getDeclaringClass();
     try {
       return myField.get(o);
@@ -43,12 +44,59 @@
   }
 
   @Override
-  public void write(Object o, Object value) {
-    Class<?> declaringClass = myField.getDeclaringClass();
-    assert declaringClass.isInstance(o) : "Wrong class: " + o.getClass() + "; should be: " + declaringClass;
+  public void set(@NotNull Object host, @Nullable Object value) {
     try {
-      Class<?> type = myField.getType();
-      myField.set(o, XmlSerializerImpl.convert(value, type));
+      myField.set(host, value);
+    }
+    catch (IllegalAccessException e) {
+      throw new XmlSerializationException("Writing " + myField, e);
+    }
+  }
+
+  @Override
+  public void setBoolean(@NotNull Object host, boolean value) {
+    try {
+      myField.setBoolean(host, value);
+    }
+    catch (IllegalAccessException e) {
+      throw new XmlSerializationException("Writing " + myField, e);
+    }
+  }
+
+  @Override
+  public void setInt(@NotNull Object host, int value) {
+    try {
+      myField.setInt(host, value);
+    }
+    catch (IllegalAccessException e) {
+      throw new XmlSerializationException("Writing " + myField, e);
+    }
+  }
+
+  @Override
+  public void setLong(@NotNull Object host, long value) {
+    try {
+      myField.setLong(host, value);
+    }
+    catch (IllegalAccessException e) {
+      throw new XmlSerializationException("Writing " + myField, e);
+    }
+  }
+
+  @Override
+  public void setFloat(@NotNull Object host, float value) {
+    try {
+      myField.setFloat(host, value);
+    }
+    catch (IllegalAccessException e) {
+      throw new XmlSerializationException("Writing " + myField, e);
+    }
+  }
+
+  @Override
+  public void setDouble(@NotNull Object host, double value) {
+    try {
+      myField.setDouble(host, value);
     }
     catch (IllegalAccessException e) {
       throw new XmlSerializationException("Writing " + myField, e);
Index: community/platform/util/src/com/intellij/util/xmlb/Binding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/Binding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/Binding.java	(revision )
@@ -33,7 +33,7 @@
   }
 
   @Nullable
-  public abstract Object serialize(Object o, @Nullable Object context, SerializationFilter filter);
+  public abstract Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter);
 
   @Nullable
   public abstract Object deserialize(Object context, @NotNull Object node);
Index: community/platform/util/src/com/intellij/util/xmlb/TagBindingWrapper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/TagBindingWrapper.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/TagBindingWrapper.java	(revision )
@@ -40,7 +40,7 @@
 
   @Nullable
   @Override
-  public Object serialize(Object o, @Nullable Object context, SerializationFilter filter) {
+  public Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter) {
     Element e = new Element(myTagName);
     Content content = (Content)myBinding.serialize(o, e, filter);
     if (content != null) {
Index: community/platform/util/src/com/intellij/util/xmlb/AttributeBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/AttributeBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/AttributeBinding.java	(revision )
@@ -16,54 +16,46 @@
 package com.intellij.util.xmlb;
 
 import com.intellij.util.xmlb.annotations.Attribute;
-import org.jdom.Content;
-import org.jdom.Text;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-public class AttributeBinding extends BasePrimitiveBinding {
+class AttributeBinding extends BasePrimitiveBinding {
+  private final Class<?> valueClass;
+
   public AttributeBinding(@NotNull Accessor accessor, @NotNull Attribute attribute) {
     super(accessor, attribute.value(), attribute.converter());
+
+    valueClass = XmlSerializerImpl.typeToClass(accessor.getGenericType());
   }
 
   @Override
   @Nullable
-  public Object serialize(@NotNull Object o, @Nullable Object context, SerializationFilter filter) {
+  public Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter) {
     Object value = myAccessor.read(o);
     if (value == null) {
       return null;
     }
 
     String stringValue;
-    if (myConverter != null) {
-      stringValue = myConverter.toString(value);
+    if (myConverter == null) {
+      stringValue = TextBinding.convertToString(value);
     }
     else {
-      assert myBinding != null;
-      Content content = (Content)myBinding.serialize(value, context, filter);
-      if (content == null) {
-        return null;
+      stringValue = myConverter.toString(value);
-      }
+    }
-
-      stringValue = content.getValue();
-    }
     return new org.jdom.Attribute(myName, stringValue);
   }
 
   @Override
   @Nullable
   public Object deserialize(Object context, @NotNull Object node) {
-    org.jdom.Attribute attribute = (org.jdom.Attribute)node;
-    assert isBoundTo(attribute);
-    Object value;
-    if (myConverter != null) {
-      value = myConverter.fromString(attribute.getValue());
+    String value = ((org.jdom.Attribute)node).getValue();
+    if (myConverter == null) {
+      TextBinding.doSet(context, value, myAccessor, valueClass);
     }
     else {
-      assert myBinding != null;
-      value = myBinding.deserialize(context, new Text(attribute.getValue()));
+      myAccessor.set(context, myConverter.fromString(value));
     }
-    myAccessor.write(context, value);
     return context;
   }
 
@@ -79,13 +71,9 @@
 
   @Override
   public void init() {
-    super.init();
-    if (myBinding != null && !Text.class.isAssignableFrom(myBinding.getBoundNodeType())) {
-      throw new XmlSerializationException("Can't use attribute binding for non-text content: " + myAccessor);
-    }
+  }
-  }
 
   public String toString() {
-    return "AttributeBinding[" + myName + ", binding=" + myBinding + "]";
+    return "AttributeBinding[" + myName + "]";
   }
 }
Index: community/platform/util/src/com/intellij/util/xmlb/CollectionBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/CollectionBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/CollectionBinding.java	(revision )
@@ -16,21 +16,16 @@
 package com.intellij.util.xmlb;
 
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
 import java.util.*;
 
 class CollectionBinding extends AbstractCollectionBinding  {
-  public CollectionBinding(ParameterizedType type, Accessor accessor) {
-    super(getComponentClass(type), Constants.COLLECTION, accessor);
+  public CollectionBinding(@NotNull ParameterizedType type, @Nullable Accessor accessor) {
+    super(XmlSerializerImpl.typeToClass(type.getActualTypeArguments()[0]), accessor);
   }
-
+  
-  private static Class getComponentClass(@NotNull ParameterizedType type) {
-    Type arg = type.getActualTypeArguments()[0];
-    return arg instanceof ParameterizedType ? (Class)((ParameterizedType)arg).getRawType() : (Class)arg;
-  }
-
   @Override
   Object processResult(Collection result, Object target) {
     if (myAccessor == null) {
@@ -55,14 +50,16 @@
   }
 
   @Override
-  protected String getCollectionTagName(Object target) {
+  protected String getCollectionTagName(@Nullable final Object target) {
     if (target instanceof Set) {
       return Constants.SET;
     }
     else if (target instanceof List) {
       return Constants.LIST;
     }
-    return super.getCollectionTagName(target);
+    else {
+      return "collection";
+    }
   }
 
   @Override
Index: community/platform/util/src/com/intellij/util/xmlb/annotations/Tag.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/annotations/Tag.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/annotations/Tag.java	(revision )
@@ -28,5 +28,6 @@
 @Target({ElementType.FIELD, ElementType.TYPE, ElementType.METHOD})
 public @interface Tag {
   String value() default "";
+
   String textIfEmpty() default "";
 }
Index: community/platform/util/src/com/intellij/util/xmlb/AccessorBindingWrapper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/AccessorBindingWrapper.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/AccessorBindingWrapper.java	(revision )
@@ -32,7 +32,7 @@
 
   @Nullable
   @Override
-  public Object serialize(Object o, @Nullable Object context, SerializationFilter filter) {
+  public Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter) {
     Object value = myAccessor.read(o);
     if (value == null) {
       throw new XmlSerializationException("Property " + myAccessor + " of object " + o + " (" + o.getClass() + ") must not be null");
@@ -50,7 +50,7 @@
     else {
       Object deserializedValue = myBinding.deserialize(currentValue, node);
       if (currentValue != deserializedValue) {
-        myAccessor.write(context, deserializedValue);
+        myAccessor.set(context, deserializedValue);
       }
     }
     return context;
@@ -66,7 +66,7 @@
     else {
       Object deserializedValue = Binding.deserializeList(myBinding, currentValue, nodes);
       if (currentValue != deserializedValue) {
-        myAccessor.write(context, deserializedValue);
+        myAccessor.set(context, deserializedValue);
       }
     }
     return context;
Index: community/platform/util/src/com/intellij/util/xmlb/OptionTagBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/OptionTagBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/OptionTagBinding.java	(revision )
@@ -21,7 +21,6 @@
 import org.jdom.Attribute;
 import org.jdom.Content;
 import org.jdom.Element;
-import org.jdom.Text;
 import org.jetbrains.annotations.NonNls;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -55,7 +54,7 @@
 
   @Override
   @Nullable
-  public Object serialize(Object o, @Nullable Object context, SerializationFilter filter) {
+  public Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter) {
     Object value = myAccessor.read(o);
     Element targetElement = new Element(myTagName);
 
@@ -67,26 +66,22 @@
       return targetElement;
     }
 
-    if (myConverter != null) {
-      targetElement.setAttribute(myValueAttribute, myConverter.toString(value));
+    if (myConverter == null) {
+      if (myBinding == null) {
+        targetElement.setAttribute(myValueAttribute, TextBinding.convertToString(value));
-    }
+      }
-    else {
-      assert myBinding != null;
-      if (myBinding instanceof BeanBinding && myValueAttribute.isEmpty()) {
+      else if (myBinding instanceof BeanBinding && myValueAttribute.isEmpty()) {
         ((BeanBinding)myBinding).serializeInto(value, targetElement, filter);
       }
       else {
         Object node = myBinding.serialize(value, targetElement, filter);
-        if (node != null) {
-          if (node instanceof Text) {
-            Text text = (Text)node;
-            targetElement.setAttribute(myValueAttribute, text.getText());
-          }
-          else if (targetElement != node) {
+        if (node != null && targetElement != node) {
-            JDOMUtil.addContent(targetElement, node);
-          }
-        }
-      }
+          JDOMUtil.addContent(targetElement, node);
+        }
+      }
+    }
+    else {
+      targetElement.setAttribute(myValueAttribute, myConverter.toString(value));
     }
     return targetElement;
   }
@@ -101,28 +96,24 @@
     if (valueAttribute == null) {
       if (myValueAttribute.isEmpty()) {
         assert myBinding != null;
-        myAccessor.write(context, myBinding.deserialize(context, element));
+        myAccessor.set(context, myBinding.deserialize(context, element));
       }
-
+      else {
-      List<Content> children = XmlSerializerImpl.getFilteredContent(element);
-      if (children.isEmpty()) {
+        List<Content> children = XmlSerializerImpl.getFilteredContent(element);
+        if (children.isEmpty()) {
-        myAccessor.write(context, null);
+          myAccessor.set(context, null);
-      }
-      else {
-        assert myBinding != null;
+        }
+        else {
+          assert myBinding != null;
-        myAccessor.write(context, Binding.deserializeList(myBinding, myAccessor.read(context), children));
+          myAccessor.set(context, Binding.deserializeList(myBinding, myAccessor.read(context), children));
-      }
-    }
+        }
+      }
-    else {
-      Object value;
-      if (myConverter == null) {
-        assert myBinding != null;
-        value = myBinding.deserialize(context, valueAttribute);
-      }
+    }
-      else {
-        value = myConverter.fromString(valueAttribute.getValue());
+    else if (myConverter == null) {
+      TextBinding.doSet(context, valueAttribute.getValue(), myAccessor, XmlSerializerImpl.typeToClass(myAccessor.getGenericType()));
-      }
+    }
-      myAccessor.write(context, value);
+    else {
+      myAccessor.set(context, myConverter.fromString(valueAttribute.getValue()));
     }
     return context;
   }
Index: community/platform/util/src/com/intellij/util/xmlb/PropertyAccessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/PropertyAccessor.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/PropertyAccessor.java	(revision )
@@ -18,6 +18,7 @@
 
 import org.jetbrains.annotations.NonNls;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 import java.beans.PropertyDescriptor;
 import java.lang.annotation.Annotation;
@@ -29,7 +30,7 @@
   private final String myName;
   private final Class<?> myType;
   private final Method myReadMethod;
-  private final Method myWriteMethod;
+  private final Method setter;
   private final Type myGenericType;
 
   public PropertyAccessor(PropertyDescriptor descriptor) {
@@ -40,12 +41,12 @@
     myName = name;
     myType = type;
     myReadMethod = readMethod;
-    myWriteMethod = writeMethod;
+    setter = writeMethod;
     myGenericType = myReadMethod.getGenericReturnType();
 
     try {
       myReadMethod.setAccessible(true);
-      myWriteMethod.setAccessible(true);
+      setter.setAccessible(true);
     }
     catch (SecurityException ignored) {
     }
@@ -65,9 +66,9 @@
   }
 
   @Override
-  public void write(Object o, Object value) {
+  public void set(@NotNull Object host, @Nullable Object value) {
     try {
-      myWriteMethod.invoke(o, XmlSerializerImpl.convert(value, myType));
+      setter.invoke(host, value);
     }
     catch (IllegalAccessException e) {
       throw new XmlSerializationException(e);
@@ -78,9 +79,34 @@
   }
 
   @Override
+  public void setBoolean(@NotNull Object host, boolean value) {
+    set(host, value);
+  }
+
+  @Override
+  public void setInt(@NotNull Object host, int value) {
+    set(host, value);
+  }
+
+  @Override
+  public void setLong(@NotNull Object host, long value) {
+    set(host, value);
+  }
+
+  @Override
+  public void setDouble(@NotNull Object host, double value) {
+    set(host, value);
+  }
+
+  @Override
+  public void setFloat(@NotNull Object host, float value) {
+    set(host, value);
+  }
+
+  @Override
   public <T extends Annotation> T getAnnotation(@NotNull Class<T> annotationClass) {
     T annotation = myReadMethod.getAnnotation(annotationClass);
-    return annotation == null ? myWriteMethod.getAnnotation(annotationClass) : annotation;
+    return annotation == null ? setter.getAnnotation(annotationClass) : annotation;
   }
 
   @Override
Index: community/platform/util/src/com/intellij/util/xmlb/JDOMElementBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/JDOMElementBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/JDOMElementBinding.java	(revision )
@@ -41,7 +41,7 @@
   }
 
   @Override
-  public Object serialize(Object o, Object context, SerializationFilter filter) {
+  public Object serialize(@NotNull Object o, Object context, @NotNull SerializationFilter filter) {
     Object value = myAccessor.read(o);
     if (value == null) {
       return null;
@@ -68,10 +68,10 @@
   public Object deserializeList(Object context, @NotNull List<?> nodes) {
     if (myAccessor.getValueClass().isArray()) {
       //noinspection SuspiciousToArrayCall
-      myAccessor.write(context, nodes.toArray(new Element[nodes.size()]));
+      myAccessor.set(context, nodes.toArray(new Element[nodes.size()]));
     }
     else {
-      myAccessor.write(context, nodes.get(0));
+      myAccessor.set(context, nodes.get(0));
     }
     return context;
   }
@@ -84,7 +84,7 @@
   @Override
   @Nullable
   public Object deserialize(Object context, @NotNull Object node) {
-    myAccessor.write(context, node);
+    myAccessor.set(context, node);
     return context;
   }
 
Index: community/platform/util/src/com/intellij/util/xmlb/DateBinding.java
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/DateBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/DateBinding.java	(date 1425025933000)
@@ -1,46 +0,0 @@
-/*
- * Copyright 2000-2014 JetBrains s.r.o.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.intellij.util.xmlb;
-
-import org.jdom.Text;
-import org.jetbrains.annotations.Nullable;
-
-import java.util.Date;
-
-/**
- * @author Dmitry Avdeev
- */
-public class DateBinding extends PrimitiveValueBinding {
-  public DateBinding(@Nullable Accessor accessor) {
-    super(Date.class, accessor);
-  }
-
-  @Nullable
-  @Override
-  public Object serialize(Object o, @Nullable Object context, SerializationFilter filter) {
-    return new Text(Long.toString(((Date)o).getTime()));
-  }
-
-  @Override
-  protected Object convertString(String value) {
-    try {
-      return new Date(Long.parseLong(value));
-    }
-    catch (NumberFormatException e) {
-      return new Date(0);
-    }
-  }
-}
Index: community/platform/util/src/com/intellij/util/xmlb/Accessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/Accessor.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/Accessor.java	(revision )
@@ -16,14 +16,25 @@
 package com.intellij.util.xmlb;
 
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
 public interface Accessor {
-  Object read(Object o);
+  Object read(@NotNull Object o);
 
-  void write(Object o, Object value);
+  void set(@NotNull Object host, @Nullable Object value);
+
+  void setBoolean(@NotNull Object host, boolean value);
+
+  void setInt(@NotNull Object host, int value);
+
+  void setLong(@NotNull Object host, long value);
+
+  void setDouble(@NotNull Object host, double value);
+
+  void setFloat(@NotNull Object host, float value);
 
   <T extends Annotation> T getAnnotation(@NotNull Class<T> annotationClass);
 
Index: community/platform/util/src/com/intellij/util/xmlb/BeanBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/BeanBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/BeanBinding.java	(revision )
@@ -344,7 +344,7 @@
 
   @NotNull
   private static Binding createBinding(@NotNull Accessor accessor) {
-    Binding binding = XmlSerializerImpl.getTypeBinding(accessor.getGenericType(), accessor);
+    Binding binding = XmlSerializerImpl.getBinding(accessor);
     if (binding instanceof JDOMElementBinding) {
       return binding;
     }
Index: community/platform/util/src/com/intellij/util/xmlb/ArrayBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/ArrayBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/ArrayBinding.java	(revision )
@@ -16,20 +16,26 @@
 package com.intellij.util.xmlb;
 
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 import java.lang.reflect.Array;
 import java.util.Arrays;
 import java.util.Collection;
 
 class ArrayBinding extends AbstractCollectionBinding  {
-  public ArrayBinding(final Class<?> valueClass, final Accessor accessor) {
-    super(valueClass.getComponentType(), Constants.ARRAY, accessor);
+  public ArrayBinding(@NotNull Class<?> valueClass, @Nullable Accessor accessor) {
+    super(valueClass.getComponentType(), accessor);
   }
 
   @Override
+  protected String getCollectionTagName(@Nullable Object target) {
+    return "array";
+  }
+
+  @Override
   @SuppressWarnings({"unchecked"})
   Object processResult(Collection result, Object target) {
-    return result.toArray((Object[])Array.newInstance(getElementType(), result.size()));
+    return result.toArray((Object[])Array.newInstance(myElementType, result.size()));
   }
 
   @NotNull
Index: community/platform/util/src/com/intellij/util/xmlb/AbstractCollectionBinding.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/AbstractCollectionBinding.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/AbstractCollectionBinding.java	(revision )
@@ -15,6 +15,7 @@
  */
 package com.intellij.util.xmlb;
 
+import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.util.SmartList;
 import com.intellij.util.containers.ContainerUtil;
 import com.intellij.util.xmlb.annotations.AbstractCollection;
@@ -31,15 +32,13 @@
 abstract class AbstractCollectionBinding extends Binding implements MultiNodeBinding {
   private Map<Class, Binding> myElementBindings;
 
-  private final Class<?> myElementType;
-  private final String myTagName;
+  protected final Class myElementType;
   private final AbstractCollection myAnnotation;
 
-  public AbstractCollectionBinding(Class elementType, String tagName, @Nullable Accessor accessor) {
+  public AbstractCollectionBinding(@NotNull Class elementType, @Nullable Accessor accessor) {
     super(accessor);
 
     myElementType = elementType;
-    myTagName = tagName;
     myAnnotation = accessor == null ? null : accessor.getAnnotation(AbstractCollection.class);
   }
 
@@ -50,28 +49,30 @@
 
   @Override
   public void init() {
-    if (myAnnotation != null) {
-      if (!myAnnotation.surroundWithTag()) {
-        if (myAnnotation.elementTag() == null) {
+    if (myAnnotation == null || myAnnotation.surroundWithTag()) {
+      return;
+    }
+
+    if (StringUtil.isEmpty(myAnnotation.elementTag())) {
-          throw new XmlSerializationException("If surround with tag is turned off, element tag must be specified for: " + myAccessor);
-        }
+      throw new XmlSerializationException("If surround with tag is turned off, element tag must be specified for: " + myAccessor);
+    }
 
-        if (myAnnotation.elementTag().equals(Constants.OPTION)) {
-          for (Binding binding : getElementBindings().values()) {
-            if (binding instanceof TagBindingWrapper) {
-              throw new XmlSerializationException("If surround with tag is turned off, element tag must be specified for: " + myAccessor);
-            }
-          }
-        }
-      }
+    if (myAnnotation.elementTag().equals(Constants.OPTION)) {
+      for (Binding binding : getElementBindings().values()) {
+        if (binding instanceof TagBindingWrapper) {
+          throw new XmlSerializationException("If surround with tag is turned off, element tag must be specified for: " + myAccessor);
+        }
+      }
+    }
+  }
-    }
-  }
 
+  @NotNull
   protected Binding getElementBinding(@NotNull Class<?> elementClass) {
-    final Binding binding = getElementBindings().get(elementClass);
+    Binding binding = getElementBindings().get(elementClass);
     return binding == null ? XmlSerializerImpl.getBinding(elementClass) : binding;
   }
 
+  @NotNull
   private synchronized Map<Class, Binding> getElementBindings() {
     if (myElementBindings == null) {
       myElementBindings = new THashMap<Class, Binding>();
@@ -86,10 +87,13 @@
     return myElementBindings;
   }
 
-  protected Binding getElementBinding(Object node) {
+  @NotNull
+  protected Binding getElementBinding(@NotNull Object node) {
     for (Binding binding : getElementBindings().values()) {
-      if (binding.isBoundTo(node)) return binding;
+      if (binding.isBoundTo(node)) {
+        return binding;
-    }
+      }
+    }
     throw new XmlSerializationException("Node " + node + " is not bound");
   }
 
@@ -100,7 +104,9 @@
   }
 
   private Binding createElementTagWrapper(final Binding elementBinding) {
-    if (myAnnotation == null) return new TagBindingWrapper(elementBinding, Constants.OPTION, Constants.VALUE);
+    if (myAnnotation == null) {
+      return new TagBindingWrapper(elementBinding, Constants.OPTION, Constants.VALUE);
+    }
 
     return new TagBindingWrapper(elementBinding,
                                  myAnnotation.elementTag() != null ? myAnnotation.elementTag() : Constants.OPTION,
@@ -114,38 +120,38 @@
 
   @Nullable
   @Override
-  public Object serialize(Object o, @Nullable Object context, SerializationFilter filter) {
-    Collection<Object> collection = o == null ? null : getIterable(o);
+  public Object serialize(@NotNull Object o, @Nullable Object context, @NotNull SerializationFilter filter) {
+    Collection<Object> collection = getIterable(o);
 
-    final String tagName = getTagName(o);
-    if (tagName != null) {
-      Element result = new Element(tagName);
+    String tagName = getTagName(o);
+    if (tagName == null) {
+      List<Object> result = new SmartList<Object>();
       if (ContainerUtil.isEmpty(collection)) {
-        return new Element(tagName);
+        return result;
       }
+
       for (Object e : collection) {
+        ContainerUtil.addIfNotNull(result, getElementBinding(e.getClass()).serialize(e, result, filter));
+      }
+      return result;
+    }
+    else {
+      Element result = new Element(tagName);
+      if (!ContainerUtil.isEmpty(collection)) {
+        for (Object e : collection) {
-        if (e == null) {
-          throw new XmlSerializationException("Collection " + myAccessor + " contains 'null' object");
-        }
+          if (e == null) {
+            throw new XmlSerializationException("Collection " + myAccessor + " contains 'null' object");
+          }
+
-        Content child = (Content)getElementBinding(e.getClass()).serialize(e, result, filter);
-        if (child != null) {
-          result.addContent(child);
-        }
-      }
+          Content child = (Content)getElementBinding(e.getClass()).serialize(e, result, filter);
+          if (child != null) {
+            result.addContent(child);
+          }
+        }
-      return result;
-    }
+      }
-    else {
-      List<Object> result = new SmartList<Object>();
-      if (ContainerUtil.isEmpty(collection)) {
-        return result;
-      }
+      return result;
+    }
-
-      for (Object e : collection) {
-        ContainerUtil.addIfNotNull(result, getElementBinding(e.getClass()).serialize(e, result, filter));
-      }
+  }
-      return result;
-    }
-  }
 
   @Nullable
   @Override
@@ -221,9 +227,11 @@
 
   @Override
   public boolean isBoundTo(Object node) {
-    if (!(node instanceof Element)) return false;
+    if (!(node instanceof Element)) {
+      return false;
+    }
 
-    final String tagName = getTagName(node);
+    String tagName = getTagName(node);
     if (tagName == null) {
       for (Binding binding : getElementBindings().values()) {
         if (binding.isBoundTo(node)) return true;
@@ -238,16 +246,10 @@
     return Element.class;
   }
 
-  public Class getElementType() {
-    return myElementType;
-  }
-
   @Nullable
-  private String getTagName(final Object target) {
+  private String getTagName(@Nullable Object target) {
     return myAnnotation == null || myAnnotation.surroundWithTag() ? getCollectionTagName(target) : null;
   }
 
-  protected String getCollectionTagName(Object target) {
-    return myTagName;
-  }
+  protected abstract String getCollectionTagName(@Nullable Object target);
 }
Index: community/platform/util/src/com/intellij/util/xmlb/Constants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- community/platform/util/src/com/intellij/util/xmlb/Constants.java	(date 1425025933000)
+++ community/platform/util/src/com/intellij/util/xmlb/Constants.java	(revision )
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.intellij.util.xmlb;
 
 import org.jetbrains.annotations.NonNls;
@@ -21,12 +20,10 @@
 public interface Constants {
   @NonNls String OPTION = "option";
   @NonNls String VALUE = "value";
-  @NonNls String COLLECTION = "collection";
   @NonNls String MAP = "map";
   @NonNls String ENTRY = "entry";
   @NonNls String KEY = "key";
   @NonNls String NAME = "name";
-  @NonNls String ARRAY = "array";
   @NonNls String SET = "set";
   @NonNls String LIST = "list";
 }
